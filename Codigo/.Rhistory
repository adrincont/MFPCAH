fun_append_i = rbind(Z1@funData[[1]]@X,Z2@funData[[1]]@X)
args_append_i = Z1@funData[[1]]@argvals
fun_append[[1]] = funData(args_append_i,fun_append_i)
if (n_fun > 1) {
for (j in 1:n_fun) {
fun_append_i = rbind(Z1@funData[[j]]@X,Z2@funData[[j]]@X)
args_append_i = Z1@funData[[j]]@argvals
fun_append[[j]] = funData(args_append_i,fun_append_i)
}
}
fmult_append = multiFunData(fun_append)
Zi = mfh_data(fun_data = fmult_append,vec_data = vec_append)
return(Zi)
}
append_Mfun(Z1,Z2)
N
lambda_i = 0.5^(1:n_vec - 1)
for (i in 1:N) {
rho_i = apply(matrix(lambda_i),1,function(x){rnorm(1,0,x)})
Zi = rho_i[1]*Xi[[1]]
for (n in 2:n_vec) {
Zi = Zi + rho_i[n]*Xi[[n]]
}
if (i == 1) {
Z = Zi
}else{
Z = append_Mfun(Z,Zi)
}
}
Z
autoplot(Z,1)
Z@vecData
Z@vecData[,1]
hist(Z@vecData[,1])
hist(Z@vecData[,2])
hist(Z@vecData[,3])
Zi
Zi@funData
Zi
Zi@funData[[1]]@argvals
Zi@funData
Zi@funData[[1]]
Zi@funData[[1]]@argvals
Zi@funData[[1]]@argvals[[1]]
length(Zi@funData[[1]]@argvals[[1]])
rnorm(length(Zi@funData[[1]]@argvals[[1]]),0,1)
Zi@funData[[1]]@X
Z@funData[[1]]@X
dim(Z@funData[[1]]@X)
matrix(ei,nrow = dim(Z@funData[[1]]@X)[1],ncol = dim(Z@funData[[1]]@X)[2])
ei = rnorm(length(Zi@funData[[1]]@argvals[[1]]),0,1)
matrix(ei,nrow = dim(Z@funData[[1]]@X)[1],ncol = dim(Z@funData[[1]]@X)[2])
matrix(ei,nrow = dim(Z@funData[[1]]@X)[1],ncol = dim(Z@funData[[1]]@X)[2],byrow = TRUE)
Zi@funData[[1]]@argvals[[1]]
Zi@vecData*0
epsilon_H = function(Zi,mean = 0, sd = 1){
ei = rnorm(length(Zi@funData[[1]]@argvals[[1]]),0,1)
Ei = matrix(ei,nrow = dim(Z@funData[[1]]@X)[1],ncol = dim(Z@funData[[1]]@X)[2],byrow = TRUE)
fun = Z@funData[[1]]@X + Ei
fun = multiFunData(list(funData(Zi@funData[[1]]@argvals[[1]],fun)))
vec = Zi@vecData*0
ei = mfh_data(fun_data = fun,vec_data = vec)
return(ei)
}
epsilon_H(Zi)
autoplot(epsilon_H(Zi))
autoplot(epsilon_H(Zi),1)
Zi
epsilon_H = function(Zi,mean = 0, sd = 1){
ei = rnorm(length(Zi@funData[[1]]@argvals[[1]]),0,1)
Ei = matrix(ei,nrow = dim(Zi@funData[[1]]@X)[1],ncol = dim(Zi@funData[[1]]@X)[2],byrow = TRUE)
fun = multiFunData(list(funData(Zi@funData[[1]]@argvals[[1]],Ei)))
vec = Zi@vecData*0
ei = mfh_data(fun_data = fun,vec_data = vec)
return(ei)
}
epsilon_H(Zi)
epsilon_H(Zi)
autoplot(epsilon_H(Zi),1)
autoplot(epsilon_H(Zi),1)
epsilon_H(Zi,mean = 0,sd = 0.4)
lambda_i = 0.5^(1:n_vec - 1)
for (i in 1:N) {
rho_i = apply(matrix(lambda_i),1,function(x){rnorm(1,0,x)})
Zi = rho_i[1]*Xi[[1]]
for (n in 2:n_vec) {
Zi = Zi + rho_i[n]*Xi[[n]]
}
Zi = Zi + epsilon_H(Zi,mean = 0,sd = 0.4)
if (i == 1) {
Z = Zi
}else{
Z = append_Mfun(Z,Zi)
}
}
autoplot(Z,1)
autoplot(Z)
r_FunH = function(n_fun,n_vec,n_grid,N,conf = 1){
# Generacion de direccion principal Xi = (Psi,Theta)
Xi = Xi_gen(n_fun = n_fun,n_vec = n_vec,n_grid = n_grid,conf = conf)
# Generacion de las observaciones
lambda_i = 0.5^(1:n_vec - 1)
for (i in 1:N) {
rho_i = apply(matrix(lambda_i),1,function(x){rnorm(1,0,x)})
Zi = rho_i[1]*Xi[[1]]
for (n in 2:n_vec) {
Zi = Zi + rho_i[n]*Xi[[n]]
}
Zi = Zi + epsilon_H(Zi,mean = 0,sd = 0.4)
if (i == 1) {
Z = Zi
}else{
Z = append_Mfun(Z,Zi)
}
}
return(Z)
}
r_FunH(n_fun,n_vec,n_grid,N,conf = 1)
autoplot(r_FunH(n_fun,n_vec,n_grid,N,conf = 1),1)
autoplot(r_FunH(n_fun,n_vec,n_grid,N,conf = 2),1)
autoplot(r_FunH(n_fun,n_vec,n_grid,N,conf = 2),1)
#.============================================================================.#
#                 Simulación de observaciones híbridas                         #
#.============================================================================.#
# [Librerias] ================================================================.#
source("library.R")
# [Funciones] ================================================================.#
source("Funciones/multiFunDataH.R") # Clase de objetos multiFunDataH
source("Funciones/multiFunDataH_plot.R") # Graficos para la clase multiFunDataH
source("Funciones/Xi_gen.R") # Generar direcciones híbridas
source("Funciones/r_FunH.R") # Generar observaciones híbridas
# [Codigo] ===================================================================.#
n_fun = 3
n_vec = 10
n_grid = 60
N = 100
# n_fun: Tamaño de la parte funcional
# n_vec: Tamaño de la parte vectorial
# n_grid: numero de puntos en la grilla
# return(): multiFunData class base de tamaño n_vec
# Generacion direccion vectorial Theta
Mat_aux = matrix(0.2,nrow = n_vec,ncol = n_vec)
diag(Mat_aux) = rep(1,n_vec)
Theta = eigen(Mat_aux)$vectors
# Generacion direccion funcional Psi
grid = (1:n_grid - 1)/(n_grid - 1)
bsplineS(grid,norder = 10)
bsplineS(grid,breaks = 10,norder = 10)
bsplineS(grid,breaks = 12,norder = 10)
bsplineS(grid,breaks = 2,norder = 10)
bsplineS(grid,breaks = 0.1,norder = 10)
bsplineS(grid,breaks = 10,norder = 10)
bsplineS(seq(0, 1, .2), 0:1, 1, 0)
bsplineS(seq(0, 1, .2), 0:1, 2, 0)
bsplineS(grid,0:1, 2, 0)
bsplineS(grid,seq(0,1,0.2), 4, 0)
ff = bsplineS(grid,seq(0,1,0.2), 4, 0)
ff[,1]
ff[,1] %*% ff[,2]
ff[,1] %*% ff[,4]
grid = (1:n_grid - 1)/(n_grid - 1)
if (conf == 1) {
## Configuracion 1
Psi = list()
for (i in 1:n_vec) {
if (i %% 2 == 0) {
Psi[[i]] = funData(grid,matrix(cos(i*pi*grid),nrow = 1))
}else{
Psi[[i]] = funData(grid,matrix(sin((i + 1)*pi*grid),nrow = 1))
}
}
}
## Configuracion 1
Psi = list()
for (i in 1:n_vec) {
if (i %% 2 == 0) {
Psi[[i]] = funData(grid,matrix(cos(i*pi*grid),nrow = 1))
}else{
Psi[[i]] = funData(grid,matrix(sin((i + 1)*pi*grid),nrow = 1))
}
}
Psi
Psi[[1]]
Psi[[1]]@X
t(Psi[[1]]@X)
(Psi[[1]]@X) %*% t(Psi[[2]]@X)
(Psi[[1]]@X) %*% t(Psi[[3]]@X)
(Psi[[1]]@X) %*% t(Psi[[4]]@X)
(Psi[[1]]@X) %*% t(Psi[[1]]@X)
(Psi[[2]]@X) %*% t(Psi[[2]]@X)
## Configuracion 2
Psi = list()
for (n in 1:n_vec) {
val = 0
for (k in 1:n) {
val_i = (factorial(n)/(factorial(k) * (factorial(n - k))))^2*(grid + 1)^(n - k)*(grid - 1)^k
val = val + val_i
}
Psi[[n]] = funData(grid,matrix(val,nrow = 1))
}
(Psi[[1]]@X) %*% t(Psi[[1]]@X)
(Psi[[1]]@X) %*% t(Psi[[2]]@X)
(Psi[[1]]@X) %*% t(Psi[[3]]@X)
(Psi[[1]]@X) %*% t(Psi[[4]]@X)
fourier(grid,nbasis = 10,period = 0.5)
ff = fourier(grid,nbasis = 10,period = 0.5)
crossprod(ff)
round(crossprod(ff),1)
round(crossprod(ff),1)
fourier(grid,nbasis = 10,period = 0.5)
fourier(grid,nbasis = 10,period = 0.5)[,-1]
crossprod(fourier(grid,nbasis = 10,period = 0.5)[,-1])
round(crossprod(fourier(grid,nbasis = 10,period = 0.5)[,-1]),1)
round(crossprod(fourier(grid,nbasis = 10,period = 0.1)[,-1]),1)
round(crossprod(fourier(grid,nbasis = 10,period = 0.1)),1)
round(crossprod(fourier(grid,nbasis = 10,period = 0.5)),1)
round(Psi,1)
## Configuracion 2
Psi = list()
for (n in 1:n_vec) {
val = 0
for (k in 1:n) {
val_i = (factorial(n)/(factorial(k) * (factorial(n - k))))^2*(grid + 1)^(n - k)*(grid - 1)^k
val = val + val_i
}
Psi[[n]] = funData(grid,matrix(val,nrow = 1))
}
Psi[[1]]
plot(Psi[[1]])
funData::norm(Psi[[1]])
funData::eFun(grid,M = 10,type = 'Poly')
ff  = funData::eFun(grid,M = 10,type = 'Poly')@X
ff
dim(ff)
t(ff)
crossprod(t(ff))
round(crossprod(t(ff)),1)
crossprod(t(ff))
ff  = funData::eFun(grid,M = 10,type = 'Fourier')@X
Psi = list()
for (i in 1:n_vec) {
if (i %% 2 == 0) {
Psi[[i]] = funData(grid,matrix(cos(i*pi*grid),nrow = 1))
}else{
Psi[[i]] = funData(grid,matrix(sin((i + 1)*pi*grid),nrow = 1))
}
}
Psi[[2]]
plot(Psi[[2]])
plot(ff[,2])
plot(ff[,2],type = "l")
plot(ff[,1],type = "l")
plot(ff[,2],type = "l")
plot(ff[,3],type = "l")
plot(ff[,10],type = "l")
ff  = funData::eFun(grid,M = 10,type = 'Fourier',)@X
ff  = funData::eFun(grid,M = 10,type = 'Poly')
plot(ff)
Psi
plot(Psi[[1]])
plot(Psi[[2]])
plot(Psi[[3]])
plot(Psi[[4]])
plot(Psi[[10]])
plot(ff[[10]])
plot(funData(grid,ff@X[1,]))
plot(funData(grid,ff@X[1,]))
ff@X[1,]
funData(grid,ff@X[1,])
funData(grid,matrix(ff@X[1,],nrow = 1))
plot(funData(grid,matrix(ff@X[1,],nrow = 1)))
plot(funData(grid,matrix(ff@X[2,],nrow = 1)))
plot(funData(grid,matrix(ff@X[3,],nrow = 1)))
plot(funData(grid,matrix(ff@X[4,],nrow = 1)))
plot(funData(grid,matrix(ff@X[5,],nrow = 1)))
plot(funData(grid,matrix(ff@X[6,],nrow = 1)))
plot(funData(grid,matrix(ff@X[7,],nrow = 1)))
plot(funData(grid,matrix(ff@X[8,],nrow = 1)))
plot(funData(grid,matrix(ff@X[9,],nrow = 1)))
plot(funData(grid,matrix(ff@X[10,],nrow = 1)))
plot(Psi[[10]])
conf = list(c("FourierLin","FourierLin","FourierLin"),c("PolyHigh","FourierLin","Wiener"))
conf
unlist(conf)
unique(unlist(conf))
base_i = eFun(grid,M = n_vec,type = name_i)
name_i = unique(unlist(conf))[1]
base_i = eFun(grid,M = n_vec,type = name_i)
base_i
base_i@X
conf = list(c("FourierLin","FourierLin","FourierLin"),c("PolyHigh","FourierLin","Wiener"))
# Generacion direccion vectorial Theta
Mat_aux = matrix(0.2,nrow = n_vec,ncol = n_vec)
diag(Mat_aux) = rep(1,n_vec)
Theta = eigen(Mat_aux)$vectors
# Generacion direccion funcional Psi
grid = (1:n_grid - 1)/(n_grid - 1)
bases_list = list()
for (name_i in unique(unlist(conf))) {
base_i = eFun(grid,M = n_vec,type = name_i)
bases_list[[name_i]] = base_i@X
}
name_i
eFun(grid,M = n_vec,type = name_i)
eFun(grid,M = n_vec,type = name_i,ignoreDeg = 1:2)
plot(eFun(grid,M = n_vec,type = name_i,ignoreDeg = 1:2))
plot(eFun(grid,M = n_vec,type = name_i,ignoreDeg = 1:2))
plot(eFun(grid,M = n_vec,type = name_i,ignoreDeg = 1))
plot(eFun(grid,M = n_vec,type = name_i,ignoreDeg = 1:2))
plot(eFun(grid,M = n_vec,type = "FourierLin",ignoreDeg = 1:2))
plot(eFun(grid,M = n_vec,type = "PolyHigh",ignoreDeg = 1:2))
plot(eFun(grid,M = n_vec,type = "Poly",ignoreDeg = 1:2))
plot(eFun(grid,M = n_vec,type = "FourierLin",ignoreDeg = 1:2))
plot(eFun(grid,M = n_vec,type = "Wiener",ignoreDeg = 1:2))
bases_list = list()
for (name_i in unique(unlist(conf))) {
base_i = eFun(grid,M = n_vec,type = name_i,ignoreDeg = 1:2)
bases_list[[name_i]] = base_i@X
}
n_fun
conf = c("PolyHigh","FourierLin","Wiener")
# Generacion direccion vectorial Theta
Mat_aux = matrix(0.2,nrow = n_vec,ncol = n_vec)
diag(Mat_aux) = rep(1,n_vec)
Theta = eigen(Mat_aux)$vectors
# Generacion direccion funcional Psi
grid = (1:n_grid - 1)/(n_grid - 1)
bases_list = list()
for (name_i in unique(conf)) {
base_i = eFun(grid,M = n_vec,type = name_i,ignoreDeg = 1:2)
bases_list[[name_i]] = base_i@X
}
conf[1]
bases_list[[conf[1]]]
bases_list[[conf[1]]][1,]
bases_list[[conf[1]]][,]
bases_list[[conf[1]]][1,]
# Generacion direccion funcional Psi
grid = (1:n_grid - 1)/(n_grid - 1)
bases_list = list()
for (name_i in unique(conf)) {
base_i = eFun(grid,M = n_vec,type = name_i,ignoreDeg = 1:2)
bases_list[[name_i]] = base_i@X
}
Psi = list()
for (i in 1:n_vec) {
Psi_i = list()
for (j in 1:n_fun) {
Psi_i[[j]] = funData(grid,bases_list[[conf[j]]][i,])
}
Psi[[i]] = multiFunData(Psi_i)
}
Psi_i
Psi_i = list()
for (j in 1:n_fun) {
Psi_i[[j]] = funData(grid,bases_list[[conf[j]]][i,])
}
bases_list[[conf[j]]]
grid = (1:n_grid - 1)/(n_grid - 1)
bases_list = list()
for (name_i in unique(conf)) {
base_i = eFun(grid,M = n_vec,type = name_i,ignoreDeg = 1:2)
bases_list[[name_i]] = base_i@X
}
Psi = list()
for (i in 1:n_vec) {
Psi_i = list()
for (j in 1:n_fun) {
Psi_i[[j]] = funData(grid,matrix(bases_list[[conf[j]]][i,],nrow = 1))
}
Psi[[i]] = multiFunData(Psi_i)
}
Psi[[1]]
plot(Psi[[1]])
plot(Psi[[2]])
plot(Psi[[3]])
plot(Psi[[4]])
plot(Psi[[5]])
Xi_gen = function(n_fun,n_vec,n_grid,conf = c("PolyHigh","FourierLin","Wiener")) {
# n_fun: Tamaño de la parte funcional
# n_vec: Tamaño de la parte vectorial
# n_grid: numero de puntos en la grilla
# return(): multiFunData class base de tamaño n_vec
# Generacion direccion vectorial Theta
Mat_aux = matrix(0.2,nrow = n_vec,ncol = n_vec)
diag(Mat_aux) = rep(1,n_vec)
Theta = eigen(Mat_aux)$vectors
# Generacion direccion funcional Psi
grid = (1:n_grid - 1)/(n_grid - 1)
bases_list = list()
for (name_i in unique(conf)) {
base_i = eFun(grid,M = n_vec,type = name_i,ignoreDeg = 1:2)
bases_list[[name_i]] = base_i@X
}
Psi = list()
for (i in 1:n_vec) {
Psi_i = list()
for (j in 1:n_fun) {
Psi_i[[j]] = funData(grid,matrix(bases_list[[conf[j]]][i,],nrow = 1))
}
Psi[[i]] = multiFunData(Psi_i)
}
## Generacion direccion hibrida Psi
Xi = list()
for (n in 1:n_vec) {
Xi[[n]] = mfh_data(fun_data = Psi[[n]],vec_data = matrix(Theta[,n],nrow = 1))
}
return(Xi)
}
lambda_i = 0.5^(1:n_vec - 1)
i = 1
rho_i = apply(matrix(lambda_i),1,function(x){rnorm(1,0,x)})
Zi = rho_i[1]*Xi[[1]]
Xi = Xi_gen(n_fun = n_fun,n_vec = n_vec,n_grid = n_grid,conf = conf)
Xi
Zi = rho_i[1]*Xi[[1]]
for (n in 2:n_vec) {
Zi = Zi + rho_i[n]*Xi[[n]]
}
autoplot(Zi)
autoplot(Zi,1)
eFun
::addError(Zi@funData)
addError(Zi@funData)
addError(Zi@funData,sd = 1)
autoplot(addError(Zi@funData,sd = 1))
autoplot(addError(Zi@funData,sd = 1))l
Zi
Zi@funData
length(Zi@funData)
mvrnorm
sd = matrix(c(0.1,0.4,0.1,0.4))
matrix(c(0.1,0.4,0.1,0.4))
matrix(c(0.1,0.4,0.1,0.4),2,2)
matrix(c(0.4,0.1,0.1,0.4),2,2)
matrix(c(0.4,0.1,0.1,0.4),3,3)
sd = matrix(0.1,3,3)
sd
diag(sd) = 0.4
sd
mvrnorm(n = length(Zi@funData[[1]]@argvals[[1]]),mu = mean,Sigma = sd)
mean
mean_i = 0
if (mean == 0) {
mean_i = rep(0,length(Zi@funData))
}
mean_i = rep(0,length(Zi@funData))
mvrnorm(n = length(Zi@funData[[1]]@argvals[[1]]),mu = mean,Sigma = sd)
mvrnorm(n = length(Zi@funData[[1]]@argvals[[1]]),mu = mean_i,Sigma = sd)
Zi@funData
mean_i = rep(0,length(Zi@funData))
ei = mvrnorm(n = length(Zi@funData[[1]]@argvals[[1]]),mu = mean_i,Sigma = sd)
vec = Zi@vecData*0
fun_list = list()
for (i in 1:length(Zi@funData)) {
Ei = matrix(ei[,i],nrow = dim(Zi@funData[[i]]@X)[1],ncol = dim(Zi@funData[[i]]@X)[2],byrow = TRUE)
fun_list[[i]] = funData(Zi@funData[[i]]@argvals[[1]],Ei)
}
fun = multiFunData(fun_list)
fun
fun[[1]]
plot(fun)
epsilon_H = function(Zi,sd){
mean_i = rep(0,length(Zi@funData))
ei = mvrnorm(n = length(Zi@funData[[1]]@argvals[[1]]),mu = mean_i,Sigma = sd)
vec = Zi@vecData*0
fun_list = list()
for (i in 1:length(Zi@funData)) {
Ei = matrix(ei[,i],nrow = dim(Zi@funData[[i]]@X)[1],ncol = dim(Zi@funData[[i]]@X)[2],byrow = TRUE)
fun_list[[i]] = funData(Zi@funData[[i]]@argvals[[1]],Ei)
}
fun = multiFunData(fun_list)
vec = Zi@vecData*0
ei = mfh_data(fun_data = fun,vec_data = vec)
return(ei)
}
sd = matrix(0.1,n_fun,n_fun)
diag(sd) = rep(0.4,n_fun)
sd
Zi + epsilon_H(Zi,sd = sd)
autoplot(Zi + epsilon_H(Zi,sd = sd),1)
source("library.R")
# [Funciones] ================================================================.#
source("Funciones/multiFunDataH.R") # Clase de objetos multiFunDataH
source("Funciones/multiFunDataH_plot.R") # Graficos para la clase multiFunDataH
source("Funciones/Xi_gen.R") # Generar direcciones híbridas
source("Funciones/r_FunH.R") # Generar observaciones híbridas
# [Codigo] ===================================================================.#
n_fun = 3
n_vec = 10
n_grid = 60
N = 100
conf = c("PolyHigh","FourierLin","Wiener")
Z = r_FunH(n_fun,n_vec,n_grid,N,conf = conf)
autoplot(Z,1)
Z
Z
Z@funData@.Data
Z@funData[[1]]
Z@funData[[1]]@X
dim(Z@funData[[1]]@X)
Z@funData[[1]]@X[,1]
plot(Z@funData[[1]]@X[,1],Z@funData[[2]]@X[,1])
plot(Z@funData[[1]]@X[,1],Z@funData[[3]]@X[,1])
plot(Z@funData[[1]]@X[,1],Z@funData[[4]]@X[,1])
plot(Z@funData[[1]]@X[,1],Z@funData[[3]]@X[,1])
plot(Z@funData[[1]]@X[,20],Z@funData[[3]]@X[,1])
plot(Z@funData[[1]]@X[,20],Z@funData[[3]]@X[,20])
plot(Z@funData[[1]]@X[,20],Z@funData[[2]]@X[,20])
plot(Z@funData[[1]]@X[,10],Z@funData[[2]]@X[,20])
Z
autoplot(Z)
